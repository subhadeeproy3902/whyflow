# WhyFlow — Master Project Prompt

## Product Name
**WhyFlow**

## One-Line Description
WhyFlow is a **decision observability system** that captures and visualizes *why* a system produced a specific outcome.

It is **not AI-specific**.  
It works for **AI-driven, rule-based, heuristic, and hybrid decision pipelines**.

---

## Core Philosophy

WhyFlow answers:

> **“Why did the system make this decision?”**

This is **decision reasoning**, not:
- performance tracing
- logging
- metrics
- execution profiling

The problem statement in `ASSIGNMENT.md` is the **source of truth** and must be strictly followed.

---

## Monorepo Setup (Already Done)

- **Turborepo** is set up
- **shadcn/ui** is configured
- **packages/ui** already contains shared UI components
- **apps/example** already exists and contains a **dummy dashboard application**
- **apps/docs** uses **Fumadocs**
- Documentation is written **only in MDX**
- All MDX files must live inside:

```
apps/docs/content/docs
```


Do **not** add documentation anywhere else.

---

## Adding UI Components (Important)

To add any new shadcn component, **always** use:

```bash
pnpm ui add <component-name>
```


Do not manually copy components.  
Do not modify shadcn internals.

---

## Theme & Design Constraints (Strict)

- Absolute theme consistency across:
  - Example dashboard
  - Documentation site
- Use **only existing shadcn tokens**:
  - `primary`
  - `secondary`
  - `card`
  - `muted`
  - `border`
  - `foreground`

### Forbidden
- No random colors
- No inline hex values
- No custom palettes
- No visual experimentation

---

## Code Quality Rules (Non-Negotiable)

- No `console logs`
- No comments explaining obvious code
- No TODOs
- No placeholder AI text
- No overengineering
- No unnecessary abstractions
- No unused exports
- No dead code

Code must feel **production-grade**, not tutorial-grade.


---

## SDK — `@whyflow/core`

### Purpose
A **minimal, explicit SDK** for capturing decision executions.

The SDK must:
- Be domain-agnostic
- Be fully serializable
- Avoid rigid schemas
- Capture *intent*, not implementation details
- Require explicit developer actions

---

### Core Concepts

#### DecisionExecution
Represents a single decision pipeline run.

Includes:
- executionId
- name
- timestamp
- ordered decision steps

#### DecisionStep
Represents a **meaningful decision point**, not a function call.

A step may include:
- input
- options / candidates
- evaluations
- output
- rationale (human-readable explanation)

---

### SDK Design Rules

- No decorators
- No global state
- No magic hooks
- No auto-instrumentation
- Everything must be explicit
- Everything must be JSON-safe

The API should feel **boring and obvious** by design.

---

## Dashboard App — `apps/example`

### Purpose
A **decision debugger**, not a marketing UI.

The dashboard visualizes a **single decision execution**, end-to-end.

---

### Dashboard Rules

- Use **only components from `packages/ui`**
- Use shadcn primitives:
  - Card
  - Badge
  - Table
  - Accordion
- No charts unless they add real clarity
- No unnecessary animations

---

### Required Views

#### Execution Overview
- Execution name
- Execution ID
- Timestamp
- Total step count

#### Step Timeline
- Vertical list of decision steps
- Each step shows:
  - name
  - type
  - short outcome summary

#### Step Detail Panel
- Input (structured JSON view)
- Output (structured JSON view)
- Rationale (plain text, prominent)
- Candidate evaluation table (if present):
  - pass / fail
  - rule-level reasoning
  - no custom colors or icons

---

## Documentation — `apps/docs` (Fumadocs)

### Writing Rules

- Documentation is **MDX only**
- Files must be placed in:

```
apps/docs/content/docs
```

- No autogenerated content
- No marketing fluff
- Clear, engineering-first tone

---

### Required Docs Pages

1. What is decision observability
2. Why logs and traces are insufficient
3. WhyFlow mental model
4. SDK usage examples
5. Data model explanation
6. How to read the dashboard

---

## Demo Data Rules

- Deterministic dummy data only
- No randomness
- No async simulation
- No API calls
- No LLM calls

The demo exists **only** to demonstrate observability.

---

## README Positioning

WhyFlow must be described as:

> A decision observability layer for systems where outcomes are produced through multiple rules, evaluations, or ranking steps.

Avoid describing it as:
- an AI debugger
- LLM observability
- a tracing system
- a logging framework
- a metrics platform

---

## Non-Goals

WhyFlow is **not**:
- A tracing system
- A logging framework
- A metrics platform
- An AI framework
- A rules engine

---

## Final Intent

This project should feel like:
- Infrastructure built by someone who has debugged real systems
- Something a founding engineer would ship
- Minimal, intentional, opinionated
- Final Result.md where there is a full outro of whats done and what can it do and how can an user notice the deeds and everything as a markdown doc for a intern beginner whom I need to provide

No bullshit.